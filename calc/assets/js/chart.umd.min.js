
/*! Tiny Chart.js-like renderer (line & grouped bar) + value labels */
(function(global){
  function Legend(ctx, labels, colors, x, y){
    ctx.font = "12px Inter, Arial"; ctx.textBaseline = "middle";
    let off = 0;
    labels.forEach((lab, idx)=>{
      const col = colors[idx % colors.length];
      ctx.fillStyle = col; ctx.fillRect(x+off, y-6, 12, 12);
      ctx.fillStyle = "#cfeaff"; ctx.fillText(lab, x+off+16, y);
      off += ctx.measureText(lab).width + 36;
    });
  }
  function scale(arr){ let min = Math.min(...arr), max = Math.max(...arr); if(!isFinite(min)||!isFinite(max)){min=0;max=1;} if(min===max) max=min+1; return {min, max}; }
  class Chart{
    constructor(ctx, config){ this.ctx = ctx; this.config = JSON.parse(JSON.stringify(config||{})); this._destroyed=false; this.draw(); }
    destroy(){ this._destroyed=true; this.ctx=null; this.config=null; }
    update(){ this.draw(); }
    draw(){
      if(this._destroyed) return;
      const c = this.ctx.canvas;
      const ctx = this.ctx;
      const dpr = window.devicePixelRatio || 1;
      c.width = c.clientWidth * dpr; c.height = c.clientHeight * dpr; ctx.setTransform(dpr,0,0,dpr,0,0);
      ctx.clearRect(0,0,c.clientWidth,c.clientHeight);

      const padding = {left:60, right:24, top:36, bottom:34};
      const W = c.clientWidth, H = c.clientHeight;
      const areaW = W - padding.left - padding.right;
      const areaH = H - padding.top - padding.bottom;

      const labels = (this.config.data && this.config.data.labels) || [];
      const datasets = (this.config.data && this.config.data.datasets) || [];

      // Axes
      ctx.strokeStyle = "rgba(160,200,255,.25)"; ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(padding.left, padding.top);
      ctx.lineTo(padding.left, H - padding.bottom);
      ctx.lineTo(W - padding.right, H - padding.bottom);
      ctx.stroke();

      // Collect values
      const all = [];
      datasets.forEach(ds => (ds.data||[]).forEach(v => { if(isFinite(v)) all.push(v);}));
      const ys = scale(all.length ? all : [0,1]);
      const yMin = Math.min(0, ys.min);
      const yMax = ys.max*1.12;

      function xPos(i){
        if(labels.length<=1){ return padding.left + areaW*0.05 + i*30; }
        const t = i/(labels.length-1); return padding.left + t*areaW;
      }
      function yPos(v){
        const t = (v - yMin)/Math.max(1e-9, (yMax - yMin));
        return (H - padding.bottom) - t*areaH;
      }

      // Grid + ticks
      ctx.fillStyle = "#9fb7ff"; ctx.font = "12px Inter, Arial";
      const ticks = 6;
      for(let ti=0; ti<=ticks; ti++){
        const v = yMin + (yMax-yMin)*ti/ticks;
        const y = yPos(v);
        ctx.strokeStyle = "rgba(160,200,255,.12)";
        ctx.beginPath(); ctx.moveTo(padding.left, y); ctx.lineTo(W - padding.right, y); ctx.stroke();
        ctx.fillText(v.toLocaleString(undefined,{maximumFractionDigits:0}), 10, y);
      }

      // Draw
      const palette = ["#6ec1ff","#ff8ea1","#8effa4","#f8d47b","#caa0ff","#73e3e8"];
      const groupW = (labels.length? areaW/labels.length : 50);

      datasets.forEach((ds, di)=>{
        const col = ds.color || palette[di%palette.length];
        if((this.config.type||"line")==="line"){
          ctx.strokeStyle = col; ctx.lineWidth = 2.2; ctx.beginPath();
          (ds.data||[]).forEach((v, i)=>{ const x = xPos(i), y = yPos(v); if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y); });
          ctx.stroke();

          if(ds.fill){
            const base = yPos(0);
            ctx.lineTo(xPos((ds.data||[]).length-1), base);
            ctx.lineTo(xPos(0), base);
            ctx.closePath();
            ctx.fillStyle = col+"33"; ctx.fill();
          }
        } else if(this.config.type==="bar"){
          const barsPerGroup = Math.max(1, datasets.length);
          const bw = groupW * 0.66 / barsPerGroup;
          const shift = (barsPerGroup * bw) / 2;
          (ds.data||[]).forEach((v, i)=>{
            const center = xPos(i);
            const x = center - shift + di*bw + 2;
            const y = yPos(v);
            const base = yPos(0);
            ctx.fillStyle = col;
            const h = Math.abs(base - y), yy = Math.min(y, base), r = Math.min(8, h/2);
            ctx.beginPath();
            ctx.moveTo(x, yy+h);
            ctx.lineTo(x, yy+r);
            ctx.quadraticCurveTo(x, yy, x+r, yy);
            ctx.lineTo(x+bw-r, yy);
            ctx.quadraticCurveTo(x+bw, yy, x+bw, yy+r);
            ctx.lineTo(x+bw, yy+h);
            ctx.closePath();
            ctx.fill();

            if(ds.showValues){
              ctx.fillStyle="#d7eaff"; ctx.font="11px Inter, Arial"; ctx.textAlign="center";
              ctx.fillText(((v||0)).toLocaleString(undefined,{maximumFractionDigits:0}), x + bw/2, yy - 6);
            }
          });
        }
      });

      // Legend
      Legend(ctx, datasets.map(d=>d.label||""), palette, padding.left, 16);
    }
  }
  global.Chart = Chart;
})(this);
