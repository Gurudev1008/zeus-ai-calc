
/*! tiny Chart.js-compatible stub for offline use (supports 'line' and 'bar' basic) */
(function(global){
  function Legend(ctx, labels, colors, x, y){
    ctx.font = "12px Arial"; ctx.textBaseline = "middle";
    let off = 0;
    labels.forEach((lab, idx)=>{
      ctx.fillStyle = colors[idx % colors.length] || "#5cf";
      ctx.fillRect(x+off, y-6, 12, 12);
      ctx.fillStyle = "#cfeaff"; ctx.fillText(lab, x+off+16, y);
      off += ctx.measureText(lab).width + 36;
    });
  }
  function scale(arr){ let min = Math.min.apply(null, arr), max = Math.max.apply(null, arr); if(min===max){max=min+1;} return {min, max}; }
  class Chart{
    constructor(ctx, config){ this.ctx = ctx; this.config = JSON.parse(JSON.stringify(config||{})); this._destroyed=false; this.draw(); }
    destroy(){ this._destroyed=true; this.ctx=null; this.config=null; }
    update(){ this.draw(); }
    draw(){
      if(this._destroyed) return;
      const c = this.ctx.canvas;
      const ctx = this.ctx;
      const dpr = window.devicePixelRatio || 1;
      c.width = c.clientWidth * dpr; c.height = c.clientHeight * dpr; ctx.scale(dpr, dpr);
      ctx.clearRect(0,0,c.clientWidth,c.clientHeight);

      const padding = {left:48, right:20, top:28, bottom:28};
      const W = c.clientWidth, H = c.clientHeight;
      const areaW = W - padding.left - padding.right;
      const areaH = H - padding.top - padding.bottom;
      const labels = (this.config.data && this.config.data.labels) || [];
      const datasets = (this.config.data && this.config.data.datasets) || [];
      // Axes
      ctx.strokeStyle = "rgba(160,200,255,.25)";
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(padding.left, padding.top);
      ctx.lineTo(padding.left, H - padding.bottom);
      ctx.lineTo(W - padding.right, H - padding.bottom);
      ctx.stroke();
      // find y scale
      const all = [];
      datasets.forEach(ds=> (ds.data||[]).forEach(v=> { if(isFinite(v)) all.push(v); }));
      const ys = scale(all.length? all: [0,1]);
      const yMin = Math.min(0, ys.min);
      const yMax = ys.max*1.05;
      function xPos(i){
        if(labels.length<=1){ return padding.left + areaW*0.02 + i*20; }
        const t = i/(labels.length-1); return padding.left + t*areaW;
      }
      function yPos(v){
        const t = (v - yMin)/Math.max(1e-9, (yMax - yMin));
        return (H - padding.bottom) - t*areaH;
      }
      // y ticks
      ctx.fillStyle = "#9fb7ff"; ctx.font = "12px Arial";
      const ticks = 5;
      for(let ti=0; ti<=ticks; ti++){
        const v = yMin + (yMax-yMin)*ti/ticks;
        const y = yPos(v);
        ctx.strokeStyle = "rgba(160,200,255,.12)"; ctx.beginPath(); ctx.moveTo(padding.left, y); ctx.lineTo(W - padding.right, y); ctx.stroke();
        ctx.fillText(v.toLocaleString(undefined,{maximumFractionDigits:0}), 4, y);
      }
      // draw
      const palette = ["#6ec1ff","#ff8ea1","#8effa4","#f8d47b","#caa0ff","#73e3e8"];
      datasets.forEach((ds, di)=>{
        const col = palette[di%palette.length];
        if((this.config.type||"line")==="line"){
          ctx.strokeStyle = col; ctx.lineWidth = 2; ctx.beginPath();
          (ds.data||[]).forEach((v, i)=>{
            const x = xPos(i), y = yPos(v);
            if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
          });
          ctx.stroke();
          if(ds.fill){
            const base = yPos(0);
            ctx.lineTo(xPos((ds.data||[]).length-1), base);
            ctx.lineTo(xPos(0), base);
            ctx.closePath();
            ctx.fillStyle = col+"33"; ctx.fill();
          }
        } else if(this.config.type==="bar"){
          const n = labels.length; const bw = areaW / Math.max(1, n) * 0.6;
          ctx.fillStyle = col;
          (ds.data||[]).forEach((v, i)=>{
            const x = xPos(i) - bw/2;
            const y = yPos(v);
            const base = yPos(0);
            ctx.fillRect(x, Math.min(y, base), bw, Math.abs(base - y));
          });
        }
      });
      // legend
      Legend(ctx, datasets.map(d=>d.label||""), palette, padding.left, 12);
    }
  }
  global.Chart = Chart;
})(this);
